--- src/Terraria/Terraria/Projectile.cs
+++ src/tModLoader/Terraria/Projectile.cs
@@ -14,6 +_,7 @@
 using Terraria.Graphics.Shaders;
 using Terraria.ID;
 using Terraria.Localization;
+using Terraria.ModLoader;
 using Terraria.Utilities;
 using Terraria.World.Generation;
 
@@ -21,6 +_,23 @@
 {
 	public class Projectile : Entity
 	{
+		public ModProjectile modProjectile {
+			get;
+			internal set;
+		}
+
+		internal GlobalProjectile[] globalProjectiles = new GlobalProjectile[0];
+
+		/// <summary>Gets the global projectile. Use this overload when you dynamically add GlobalProjectile manually.</summary>
+		public GlobalProjectile GetGlobalProjectile(Mod mod, string name) => ProjectileLoader.GetGlobalProjectile(this, mod, name).Instance(this);
+
+		/// <summary>Gets the global projectile. Use this overload when you know only 1 instance will ever be added by this particular mod.</summary>
+		[Obsolete("Use GetGlobalProjectile<T>() instead", true)]
+		public T GetGlobalProjectile<T>(Mod mod) where T : GlobalProjectile => (T)GetGlobalProjectile(mod, typeof(T).Name);
+
+		/// <summary>Gets the global projectile. Use this overload when you know only 1 instance will ever be added among all mods. 99% of mods should use this.</summary>
+		public T GetGlobalProjectile<T>() where T : GlobalProjectile => (T)ModContent.GetInstance<T>().Instance(this);
+
 		public static uint[][] perIDStaticNPCImmunity = new uint[714][];
 		public static int SentryLifeTime = 7200;
 		public float ownerHitCheckDistance = 1000f;
@@ -51,9 +_,9 @@
 		public float knockBack;
 		public bool friendly;
 		public int penetrate = 1;
-		private int[] localNPCImmunity = new int[200];
+		public int[] localNPCImmunity = new int[200];
-		private bool usesLocalNPCImmunity;
+		public bool usesLocalNPCImmunity;
-		private bool usesIDStaticNPCImmunity;
+		public bool usesIDStaticNPCImmunity;
 		public int maxPenetrate = 1;
 		public int identity;
 		public float light;
@@ -90,10 +_,13 @@
 		public int localNPCHitCooldown = -2;
 		public int idStaticNPCHitCooldown = -1;
 		private static float[] _CompanionCubeScreamCooldown = new float[255];
-
+		private string nameOverride = null;
 		public string Name {
 			get {
-				return Lang.GetProjectileName(type).Value;
+				return nameOverride ?? Lang.GetProjectileName(type).Value;
+			}
+			set {
+				nameOverride = value;
 			}
 		}
 
@@ -140,7 +_,7 @@
 		}
 
 		public static void ResetImmunity() {
-			for (int i = 0; i < 714; i++) {
+			for (int i = 0; i < perIDStaticNPCImmunity.Length; i++) {
 				for (int j = 0; j < 200; j++) {
 					perIDStaticNPCImmunity[i][j] = 0u;
 				}
@@ -189,7 +_,31 @@
 			return DD2Event.Ongoing;
 		}
 
+		public void CloneDefaults(int TypeToClone) {
+			int originalType = type;
+			ModProjectile originalModProjectile = modProjectile;
+			SetDefaults(TypeToClone);
+			type = originalType;
+			modProjectile = originalModProjectile;
+			int num = ProjectileID.Sets.TrailCacheLength[type];
+			if (num != oldPos.Length) {
+				Array.Resize(ref oldPos, num);
+				Array.Resize(ref oldRot, num);
+				Array.Resize(ref oldSpriteDirection, num);
+			}
+
+			for (int i = 0; i < oldPos.Length; i++) {
+				oldPos[i].X = 0f;
+				oldPos[i].Y = 0f;
+				oldRot[i] = 0f;
+				oldSpriteDirection[i] = 0;
+			}
+		}
+
 		public void SetDefaults(int Type) {
+			modProjectile = null;
+			globalProjectiles = new GlobalProjectile[0];
+			nameOverride = null;
 			ownerHitCheckDistance = 1000f;
 			counterweight = false;
 			sentry = false;
@@ -6394,14 +_,12 @@
 					hostile = true;
 					penetrate = -1;
 				}
-				else {
-					active = false;
-				}
 			}
 
 		IL_C73D:
+			ProjectileLoader.SetDefaults(this);
+
 			width = (int)(width * scale);
-
 			height = (int)(height * scale);
 			maxPenetrate = penetrate;
 		}
@@ -6418,6 +_,7 @@
 			return result;
 		}
 
+		public static Projectile NewProjectileDirect(Vector2 position, Vector2 velocity, int Type, int Damage, float KnockBack, int Owner = 255, float ai0 = 0f, float ai1 = 0f) => Main.projectile[Projectile.NewProjectile(position.X, position.Y, velocity.X, velocity.Y, Type, Damage, KnockBack, Owner, ai0, ai1)];
 		public static int NewProjectile(Vector2 position, Vector2 velocity, int Type, int Damage, float KnockBack, int Owner = 255, float ai0 = 0f, float ai1 = 0f) => Projectile.NewProjectile(position.X, position.Y, velocity.X, velocity.Y, Type, Damage, KnockBack, Owner, ai0, ai1);
 
 		public static int NewProjectile(float X, float Y, float SpeedX, float SpeedY, int Type, int Damage, float KnockBack, int Owner = 255, float ai0 = 0f, float ai1 = 0f) {
@@ -6484,7 +_,7 @@
 				projectile.ai[1] = projectile.position.Y;
 			}
 
-			if (Type > 0 && Type < 714) {
+			if (Type > 0) {
 				if (ProjectileID.Sets.NeedsUUID[Type])
 					projectile.projUUID = projectile.identity;
 
@@ -7202,7 +_,10 @@
 			if (aiStyle == 10 && localAI[1] == -1f)
 				return;
 
-			if (Main.projPet[type] && type != 266 && type != 407 && type != 317 && (type != 388 || ai[0] != 2f) && (type < 390 || type > 392) && (type < 393 || type > 395) && (type != 533 || ai[0] < 6f || ai[0] > 8f) && (type < 625 || type > 628))
+			if (Main.projPet[type] && type != 266 && type != 407 && type != 317 && (type != 388 || ai[0] != 2f) && (type < 390 || type > 392) && (type < 393 || type > 395) && (type != 533 || ai[0] < 6f || ai[0] > 8f) && (type < 625 || type > 628) && !ProjectileLoader.MinionContactDamage(this))
+				return;
+
+			if (!ProjectileLoader.CanDamage(this))
 				return;
 
 			Rectangle myRect = new Rectangle((int)position.X, (int)position.Y, width, height);
@@ -7230,6 +_,7 @@
 				myRect.Height += num3 * 2;
 			}
 
+			ProjectileLoader.ModifyDamageHitbox(this, ref myRect);
 			if (friendly && owner == Main.myPlayer && !npcProj) {
 				if (aiStyle == 16 && type != 338 && type != 339 && type != 340 && type != 341 && (timeLeft <= 1 || type == 108 || type == 164) || type == 286 && localAI[1] == -1f) {
 					int myPlayer = Main.myPlayer;
@@ -7259,13 +_,35 @@
 			if (owner == Main.myPlayer) {
 				if (damage > 0) {
 					for (int i = 0; i < 200; i++) {
-						bool flag = !usesLocalNPCImmunity && !usesIDStaticNPCImmunity || usesLocalNPCImmunity && localNPCImmunity[i] == 0 || usesIDStaticNPCImmunity && IsNPCImmune(type, i);
-						if (Main.npc[i].active && !Main.npc[i].dontTakeDamage && flag && (friendly && (!Main.npc[i].friendly || type == 318 || Main.npc[i].type == 22 && owner < 255 && Main.player[owner].killGuide || Main.npc[i].type == 54 && owner < 255 && Main.player[owner].killClothier) || hostile && Main.npc[i].friendly && !Main.npc[i].dontTakeDamageFromHostiles) && (owner < 0 || Main.npc[i].immune[owner] == 0 || maxPenetrate == 1)) {
+						if (!Main.npc[i].active || Main.npc[i].dontTakeDamage)
+							continue;
+
+						bool immunityTimerInactive = !usesLocalNPCImmunity && !usesIDStaticNPCImmunity || usesLocalNPCImmunity && localNPCImmunity[i] == 0 || usesIDStaticNPCImmunity && IsNPCImmune(type, i);
+						if (!immunityTimerInactive)
+							continue;
+
+						bool? modCanHit = ProjectileLoader.CanHitNPC(this, Main.npc[i]);
+						if (modCanHit.HasValue && !modCanHit.Value)
+							continue;
+
+						bool? modCanBeHit = NPCLoader.CanBeHitByProjectile(Main.npc[i], this);
+						if (modCanBeHit.HasValue && !modCanBeHit.Value)
+							continue;
+
+						bool? modCanHit2 = PlayerHooks.CanHitNPCWithProj(this, Main.npc[i]);
+						if (modCanHit2.HasValue && !modCanHit2.Value)
+							continue;
+
+						bool canHitFlag = modCanHit.HasValue && modCanHit.Value || modCanBeHit.HasValue && modCanBeHit.Value || modCanHit2.HasValue && modCanHit2.Value;
+						if ((canHitFlag || friendly && (!Main.npc[i].friendly || type == 318 || Main.npc[i].type == 22 && owner < 255 && Main.player[owner].killGuide || Main.npc[i].type == 54 && owner < 255 && Main.player[owner].killClothier) || hostile && Main.npc[i].friendly && !Main.npc[i].dontTakeDamageFromHostiles) && (owner < 0 || Main.npc[i].immune[owner] == 0 || maxPenetrate == 1)) {
 							bool flag2 = false;
 							if (type == 11 && (Main.npc[i].type == 47 || Main.npc[i].type == 57))
 								flag2 = true;
 							else if (type == 31 && Main.npc[i].type == 69)
 								flag2 = true;
+
+							if (canHitFlag)
+								flag2 = false;
 							else if (Main.npc[i].trapImmune && trap)
 								flag2 = true;
 							else if (Main.npc[i].immortal && npcProj)
@@ -7296,7 +_,7 @@
 									}
 
 									int num6 = damage;
-									if (type > 0 && type < 714 && ProjectileID.Sets.StardustDragon[type]) {
+									if (type > 0 && ProjectileID.Sets.StardustDragon[type]) {
 										float num7 = (scale - 1f) * 100f;
 										num7 = Utils.Clamp(num7, 0f, 50f);
 										num6 = (int)(num6 * (1f + num7 * 0.23f));
@@ -7521,7 +_,7 @@
 											num8 = (int)(num8 * 0.75);
 									}
 
-									if (Main.netMode != 2 && Main.npc[i].type == 439 && type >= 0 && type <= 714 && ProjectileID.Sets.Homing[type])
+									if (Main.netMode != 2 && Main.npc[i].type == 439 && type >= 0 && ProjectileID.Sets.Homing[type])
 										num8 = (int)(num8 * 0.75f);
 
 									if (type == 497 && penetrate != 1) {
@@ -7581,6 +_,14 @@
 										Main.player[owner].ClearBuff(198);
 									}
 
+									float knockback = knockBack;
+									int hitDirection = direction;
+									if (type == 697 || type == 699 || type == 707 || type == 708)
+										hitDirection = Main.player[owner].Center.X < Main.npc[i].Center.X ? 1 : -1;
+
+									ProjectileLoader.ModifyHitNPC(this, Main.npc[i], ref num8, ref knockback, ref flag5, ref hitDirection);
+									NPCLoader.ModifyHitByProjectile(Main.npc[i], this, ref num8, ref knockback, ref flag5, ref hitDirection);
+									PlayerHooks.ModifyHitNPCWithProj(this, Main.npc[i], ref num8, ref knockback, ref flag5, ref hitDirection);
 									StatusNPC(i);
 									if (flag4 && type != 221 && type != 227 && type != 614)
 										Main.player[owner].OnHit(Main.npc[i].Center.X, Main.npc[i].Center.Y, Main.npc[i]);
@@ -7590,18 +_,14 @@
 										netUpdate = true;
 									}
 
-									int hitDirection = direction;
-									if (type == 697 || type == 699 || type == 707 || type == 708)
-										hitDirection = Main.player[owner].Center.X < Main.npc[i].Center.X ? 1 : -1;
-
 									if (flag4 && !hostile && Main.player[owner].armorPenetration > 0)
 										num8 += Main.npc[i].checkArmorPenetration(Main.player[owner].armorPenetration);
 
 									int num21;
-									if (flag4)
-										num21 = (int)Main.npc[i].StrikeNPC(num8, knockBack, hitDirection, flag5, false, false);
+									if (flag4) // patch note: use local variable 'knockback', not knockBack
+										num21 = (int)Main.npc[i].StrikeNPC(num8, knockback, hitDirection, flag5, false, false);
 									else
-										num21 = (int)Main.npc[i].StrikeNPCNoInteraction(num8, knockBack, hitDirection, flag5, false, false);
+										num21 = (int)Main.npc[i].StrikeNPCNoInteraction(num8, knockback, hitDirection, flag5, false, false);
 
 									if (flag4 && Main.player[owner].accDreamCatcher)
 										Main.player[owner].addDPS(num21);
@@ -7676,10 +_,10 @@
 										Projectile.NewProjectile(Main.npc[i].Center.X, Main.npc[i].Center.Y, Main.npc[i].velocity.X, Main.npc[i].velocity.Y, 289, 0, 0f, owner, 0f, 0f);
 
 									if (Main.netMode != 0) {
-										if (flag5)
-											NetMessage.SendData(28, -1, -1, null, i, num8, knockBack, direction, 1, 0, 0);
+										if (flag5) // patch note: use local variable 'knockback', not knockBack
+											NetMessage.SendData(28, -1, -1, null, i, num8, knockback, direction, 1, 0, 0);
 										else
-											NetMessage.SendData(28, -1, -1, null, i, num8, knockBack, direction, 0, 0, 0);
+											NetMessage.SendData(28, -1, -1, null, i, num8, knockback, direction, 0, 0, 0);
 									}
 
 									if (type >= 390 && type <= 392)
@@ -7810,6 +_,9 @@
 									if (type == 710)
 										BetsySharpnel(i);
 
+									ProjectileLoader.OnHitNPC(this, Main.npc[i], num21, knockback, flag5);
+									NPCLoader.OnHitByProjectile(Main.npc[i], this, num21, knockback, flag5);
+									PlayerHooks.OnHitNPCWithProj(this, Main.npc[i], num21, knockback, flag5);
 									if (penetrate > 0 && type != 317) {
 										if (type == 357)
 											damage = (int)(damage * 0.9);
@@ -7894,7 +_,7 @@
 					for (int n = 0; n < 255; n++) {
 						if (n != owner && Main.player[n].active && !Main.player[n].dead && !Main.player[n].immune && Main.player[n].hostile && playerImmune[n] <= 0 && (Main.player[Main.myPlayer].team == 0 || Main.player[Main.myPlayer].team != Main.player[n].team) && (!ownerHitCheck || CanHit(Main.player[n]))) {
 							bool flag6 = Colliding(myRect, Main.player[n].getRect());
-							if (flag6) {
+							if (ProjectileLoader.CanHitPvp(this, Main.player[n]) && PlayerHooks.CanHitPvpWithProj(this, Main.player[n]) && flag6) {
 								if (aiStyle == 3) {
 									if (ai[0] == 0f) {
 										velocity.X = -velocity.X;
@@ -7932,12 +_,15 @@
 									flag7 = true;
 
 								int num30 = Main.DamageVar(damage);
+								ProjectileLoader.ModifyHitPvp(this, Main.player[n], ref num30, ref flag7);
+								PlayerHooks.ModifyHitPvpWithProj(this, Main.player[n], ref num30, ref flag7);
 								if (!Main.player[n].immune)
 									StatusPvP(n);
 
 								if (type != 221 && type != 227 && type != 614)
 									Main.player[owner].OnHit(Main.player[n].Center.X, Main.player[n].Center.Y, Main.player[n]);
 
+								//patch file: num31
 								int num31 = (int)Main.player[n].Hurt(playerDeathReason, num30, direction, true, false, flag7, -1);
 								if (num31 > 0 && Main.player[owner].ghostHeal && friendly && !hostile)
 									ghostHeal(num31, new Vector2(Main.player[n].Center.X, Main.player[n].Center.Y));
@@ -7948,6 +_,8 @@
 								if (melee && Main.player[owner].meleeEnchant == 7)
 									Projectile.NewProjectile(Main.player[n].Center.X, Main.player[n].Center.Y, Main.player[n].velocity.X, Main.player[n].velocity.Y, 289, 0, 0f, owner, 0f, 0f);
 
+								ProjectileLoader.OnHitPvp(this, Main.player[n], num31, flag7);
+								PlayerHooks.OnHitPvpWithProj(this, Main.player[n], num31, flag7);
 								if (Main.netMode != 0)
 									NetMessage.SendPlayerHurt(n, playerDeathReason, num30, direction, flag7, true, 0, -1, -1);
 
@@ -8036,10 +_,13 @@
 				if (type == 455 || type == 452 || type == 454 || type == 462)
 					num35 = 1;
 
+				if (modProjectile != null)
+					num35 = modProjectile.cooldownSlot;
+
 				int myPlayer2 = Main.myPlayer;
 				if (Main.player[myPlayer2].active && !Main.player[myPlayer2].dead && (!Main.player[myPlayer2].immune || num35 != -1)) {
 					bool flag8 = Colliding(myRect, Main.player[myPlayer2].getRect());
-					if (flag8) {
+					if (ProjectileLoader.CanHitPlayer(this, Main.player[myPlayer2]) && PlayerHooks.CanBeHitByProjectile(Main.player[myPlayer2], this) && flag8) {
 						int hitDirection2 = direction;
 						if (Main.player[myPlayer2].position.X + Main.player[myPlayer2].width / 2 < position.X + width / 2)
 							hitDirection2 = -1;
@@ -8048,6 +_,9 @@
 
 						if (!Main.player[myPlayer2].CanParryAgainst(Main.player[myPlayer2].Hitbox, Hitbox, velocity)) {
 							int num36 = Main.DamageVar(damage);
+							bool crit = false;
+							ProjectileLoader.ModifyHitPlayer(this, Main.player[myPlayer2], ref num36, ref crit);
+							PlayerHooks.ModifyHitByProjectile(Main.player[myPlayer2], this, ref num36, ref crit);
 							if (!Main.player[myPlayer2].immune)
 								StatusPlayer(myPlayer2);
 
@@ -8057,12 +_,15 @@
 							if (Main.expertMode)
 								num36 = (int)(num36 * Main.expertDamage);
 
-							Main.player[myPlayer2].Hurt(PlayerDeathReason.ByProjectile(-1, whoAmI), num36 * 2, hitDirection2, false, false, false, num35);
+							int realDamage = (int)Main.player[myPlayer2].Hurt(PlayerDeathReason.ByProjectile(-1, whoAmI), num36 * 2, hitDirection2, false, false, false, num35);
 							if (trap) {
 								Main.player[myPlayer2].trapDebuffSource = true;
 								if (Main.player[myPlayer2].dead)
 									AchievementsHelper.HandleSpecialEvent(Main.player[myPlayer2], 4);
 							}
+
+							ProjectileLoader.OnHitPlayer(this, Main.player[myPlayer2], realDamage, crit);
+							PlayerHooks.OnHitByProjectile(Main.player[myPlayer2], this, realDamage, crit);
 						}
 
 						bool flag9 = true;
@@ -8158,11 +_,18 @@
 					Utils.PlotTileLine(Center + f.ToRotationVector2() * -num5, Center + f.ToRotationVector2() * num5, (float)width * scale, new Utils.PerLinePoint(DelegateMethods.CutTiles));
 				}
 
+				ProjectileLoader.CutTiles(this);
 				AchievementsHelper.CurrentlyMining = false;
 			}
 		}
 
+		private bool CanCutTiles() {
+			bool? canCutTiles = ProjectileLoader.CanCutTiles(this);
+			if (canCutTiles.HasValue)
+				return canCutTiles.Value;
+
-		private bool CanCutTiles() => aiStyle != 45 && aiStyle != 137 && aiStyle != 92 && aiStyle != 105 && aiStyle != 106 && type != 463 && type != 69 && type != 70 && type != 621 && type != 10 && type != 11 && type != 379 && type != 407 && type != 476 && type != 623 && (type < 625 || type > 628);
+			return aiStyle != 45 && aiStyle != 137 && aiStyle != 92 && aiStyle != 105 && aiStyle != 106 && type != 463 && type != 69 && type != 70 && type != 621 && type != 10 && type != 11 && type != 379 && type != 407 && type != 476 && type != 623 && (type < 625 || type > 628);
+		}
 
 		public bool Colliding(Rectangle myRect, Rectangle targetRect) {
 			if (type == 598 && targetRect.Width > 8 && targetRect.Height > 8) {
@@ -8196,6 +_,10 @@
 				return false;
 			}
 
+			bool? modColliding = ProjectileLoader.Colliding(this, myRect, targetRect);
+			if (modColliding.HasValue)
+				return modColliding.Value;
+
 			if (myRect.Intersects(targetRect))
 				return true;
 
@@ -9309,15 +_,19 @@
 					overrideHeight = (int)(20f * scale);
 				}
 
+				if (!ProjectileLoader.TileCollideStyle(this, ref overrideWidth, ref overrideHeight, ref flag6)) {
+				}
-				if ((type != 440 && type != 449 && type != 606 || ai[1] != 1f) && (type != 466 || localAI[1] != 1f) && (type != 580 || localAI[1] <= 0f) && (type != 640 || localAI[1] <= 0f)) {
+				else if ((type != 440 && type != 449 && type != 606 || ai[1] != 1f) && (type != 466 || localAI[1] != 1f) && (type != 580 || localAI[1] <= 0f) && (type != 640 || localAI[1] <= 0f)) {
 					if (aiStyle == 10) {
 						if (type == 42 || type == 65 || type == 68 || type == 354 || type == 31 && ai[0] == 2f)
+							//patch file: flag6
 							this.velocity = Collision.TileCollision(position, this.velocity, width, height, flag6, flag6, 1);
 						else
 							this.velocity = Collision.AnyCollision(position, this.velocity, width, height, true);
 					}
 					else {
 						Vector2 vector2 = position;
+						//patch file: overrideWidth, overrideHeight
 						int num2 = overrideWidth != -1 ? overrideWidth : width;
 						int num3 = overrideHeight != -1 ? overrideHeight : height;
 						if (overrideHeight != -1 || overrideWidth != -1) {
@@ -9475,7 +_,9 @@
 					flag = true;
 
 				if (flag) {
+					if (!ProjectileLoader.OnTileCollide(this, velocity)) {
+					}
-					if (type == 663 || type == 665 || type == 667 || type == 677 || type == 678 || type == 679 || type == 691 || type == 692 || type == 693 || type == 688 || type == 689 || type == 690) {
+					else if (type == 663 || type == 665 || type == 667 || type == 677 || type == 678 || type == 679 || type == 691 || type == 692 || type == 693 || type == 688 || type == 689 || type == 690) {
 						position += this.velocity;
 						this.velocity = Vector2.Zero;
 					}
@@ -10178,6 +_,9 @@
 				if (type == 540)
 					return;
 
+				if (!ProjectileLoader.ShouldUpdatePosition(this))
+					return;
+
 				if (wet)
 					position += wetVelocity;
 				else
@@ -10220,9 +_,11 @@
 				while (Main.tile[i, num6].liquid > 0 && !WorldGen.SolidTile(i, num6) && num6 < Main.maxTilesY - 10) {
 					num5++;
 					num6++;
+					//patch file: flag, num5
 					if (Main.tile[i, num6].lava())
 						flag = true;
 					else if (Main.tile[i, num6].honey())
+						//patch file: flag2
 						flag2 = true;
 				}
 			}
@@ -10235,6 +_,7 @@
 				return;
 			}
 
+			//patch file: num7
 			int num7 = Main.player[owner].FishingLevel();
 			if (num7 == 0)
 				return;
@@ -10284,6 +_,7 @@
 			if (num2 < Main.worldSurface * 0.5)
 				num14 = 0;
 			else if (num2 < Main.worldSurface)
+				//patch file: num14
 				num14 = 1;
 			else if (num2 < Main.rockLayer)
 				num14 = 2;
@@ -10338,12 +_,14 @@
 				num21 += 10;
 
 			int num22 = Main.anglerQuestItemNetIDs[Main.anglerQuest];
+			//patch file: num22
 			if (Main.player[owner].HasItem(num22))
 				num22 = -1;
 
 			if (Main.anglerQuestFinished)
 				num22 = -1;
 
+			bool junk = false;
 			if (flag) {
 				if (!ItemID.Sets.CanFishInLava[Main.player[owner].HeldItem.type])
 					return;
@@ -10363,6 +_,7 @@
 			}
 			else if (Main.rand.Next(50) > num7 && Main.rand.Next(50) > num7 && num5 < num8) {
 				num13 = Main.rand.Next(2337, 2340);
+				junk = true;
 			}
 			else if (Main.rand.Next(100) < num21) {
 				if (flag6 || flag7)
@@ -10616,6 +_,9 @@
 				}
 			}
 
+			PlayerHooks.CatchFish(Main.player[owner], Main.player[owner].inventory[Main.player[owner].selectedItem],
+				num7, flag ? 1 : flag2 ? 2 : 0, num5, num14, num22, ref num13, ref junk);
+
 			if (num13 > 0) {
 				if (Main.player[owner].sonarPotion) {
 					Item item = new Item();
@@ -10663,6 +_,9 @@
 						return 0.31f + (float)Math.Cos(Main.time / 120.0 * 6.2831854820251465) * 0.03f;
 					case "Random":
 						return Main.rand.NextFloat();
+					case "bluemagic123":
+					case "blushiemagic":
+						return 0.55f + (float)Math.Cos(Main.time / 120.0 * 6.2831854820251465) * 0.1f;
 				}
 			}
 
@@ -10708,6 +_,10 @@
 		}
 
 		public void AI() {
+			ProjectileLoader.ProjectileAI(this);
+		}
+
+		public void VanillaAI() {
 			if (aiStyle == 1) {
 				AI_001();
 				return;
@@ -11660,6 +_,9 @@
 						if (num71 > num72)
 							ai[0] = 1f;
 					}
+					else if (ProjectileLoader.GrappleOutOfRange(num71, this)) {
+						ai[0] = 1f;
+					}
 
 					Vector2 value4 = Center - new Vector2(5f);
 					Vector2 value5 = Center + new Vector2(5f);
@@ -11723,6 +_,7 @@
 										if (type >= 646 && type <= 649)
 											num83 = 4;
 
+										ProjectileLoader.NumGrappleHooks(this, Main.player[owner], ref num83);
 										for (int num84 = 0; num84 < 1000; num84++) {
 											if (Main.projectile[num84].active && Main.projectile[num84].owner == owner && Main.projectile[num84].aiStyle == 7) {
 												if (Main.projectile[num84].timeLeft < num81) {
@@ -11799,6 +_,7 @@
 					if (type == 332)
 						num85 = 17f;
 
+					ProjectileLoader.GrappleRetreatSpeed(this, Main.player[owner], ref num85);
 					if (num71 < 24f)
 						Kill();
 
@@ -20387,7 +_,7 @@
 																							}
 
 																							if (Main.myPlayer == owner) {
-																								bool flag43 = !flag41 || player5.CheckMana(player5.inventory[player5.selectedItem].mana, true, false);
+																								bool flag43 = !flag41 || player5.CheckMana(player5.inventory[player5.selectedItem], -1, true, false);
 																								bool flag44 = player5.channel && flag43;
 																								if (!flag42 && !flag44 || ai[0] == 180f) {
 																									Vector2 vector97 = player5.Center + new Vector2(player5.direction * 4, player5.gravDir * 2f);
@@ -23785,7 +_,7 @@
 					Rectangle rectangle = new Rectangle((int)position.X, (int)position.Y, width, height);
 					Rectangle value = new Rectangle((int)Main.player[owner].position.X, (int)Main.player[owner].position.Y, Main.player[owner].width, Main.player[owner].height);
 					if (rectangle.Intersects(value)) {
-						if (ai[1] > 0f && ai[1] < 3930f) {
+						if (ai[1] > 0f) {
 							int num8 = (int)ai[1];
 							Item item = new Item();
 							item.SetDefaults(num8, false);
@@ -23829,6 +_,7 @@
 								item.stack = stack2;
 							}
 
+							ItemLoader.CaughtFishStack(item);
 							item.newAndShiny = true;
 							Item item2 = Main.player[owner].GetItem(owner, item, false, false);
 							if (item2.stack > 0) {
@@ -30643,7 +_,7 @@
 				}
 
 				if (flag && Main.myPlayer == owner) {
-					bool flag2 = player.channel && player.CheckMana(player.inventory[player.selectedItem].mana, true, false) && !player.noItems && !player.CCed;
+					bool flag2 = player.channel && player.CheckMana(player.inventory[player.selectedItem], -1, true, false) && !player.noItems && !player.CCed;
 					if (flag2) {
 						float scaleFactor = player.inventory[player.selectedItem].shootSpeed * scale;
 						Vector2 value2 = vector;
@@ -30848,7 +_,7 @@
 				}
 
 				if (flag6 && Main.myPlayer == owner) {
-					bool flag7 = !flag4 || player.CheckMana(player.inventory[player.selectedItem].mana, true, false);
+					bool flag7 = !flag4 || player.CheckMana(player.inventory[player.selectedItem], -1, true, false);
 					bool flag8 = player.channel && flag7 && !player.noItems && !player.CCed;
 					if (flag8) {
 						if (ai[0] == 180f) {
@@ -30948,7 +_,7 @@
 				}
 
 				if (flag10 && Main.myPlayer == owner) {
-					bool flag11 = !flag9 || player.CheckMana(player.inventory[player.selectedItem].mana, true, false);
+					bool flag11 = !flag9 || player.CheckMana(player.inventory[player.selectedItem], -1, true, false);
 					bool flag12 = player.channel && flag11 && !player.noItems && !player.CCed;
 					if (flag12) {
 						if (ai[0] == 1f) {
@@ -31725,6 +_,11 @@
 			num7 /= (1f + Main.player[owner].meleeSpeed * 3f) / 4f;
 			num8 /= (1f + Main.player[owner].meleeSpeed * 3f) / 4f;
 			float num11 = 14f - num8 / 2f;
+			// Yoyos with effective top speed (boosted by melee speed) num8 > 26 will set num11 to be less than 1.
+			// This breaks the AI's acceleration vector math and stops the velocity from being correctly capped every frame.
+			// Providing a minimum value of 1.01 to num11 fixes this, allowing for very fast modded yoyos.
+			// See issue #751 for more details.
+			if (num11 < 1.01f) num11 = 1.01f;
 			float num12 = 5f + num8 / 2f;
 			if (flag)
 				num12 += 20f;
@@ -32285,7 +_,7 @@
 							if (tileSafely.active() && Main.tileSolid[tileSafely.type] && !Main.tileSolidTop[tileSafely.type] && !Main.tileFrameImportant[tileSafely.type]) {
 								Tile tileSafely2 = Framing.GetTileSafely(i, j - 1);
 								if (!tileSafely2.active() || !Main.tileSolid[tileSafely2.type] || Main.tileSolidTop[tileSafely2.type]) {
-									int num4 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely);
+									int num4 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, i, j);
 									for (int k = 0; k < num4; k++) {
 										Dust dust = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 										Dust expr_1D5_cp_0 = dust;
@@ -32785,7 +_,7 @@
 							if (tileSafely.active() && Main.tileSolid[tileSafely.type] && !Main.tileSolidTop[tileSafely.type] && !Main.tileFrameImportant[tileSafely.type]) {
 								Tile tileSafely2 = Framing.GetTileSafely(i, j - 1);
 								if (!tileSafely2.active() || !Main.tileSolid[tileSafely2.type] || Main.tileSolidTop[tileSafely2.type]) {
-									int num2 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely) * 6;
+									int num2 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, i, j) * 6;
 									for (int k = 0; k < num2; k++) {
 										Dust dust = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 										Dust expr_16B_cp_0 = dust;
@@ -33347,6 +_,11 @@
 			Main.projectileIdentity[owner, identity] = -1;
 			int num = timeLeft;
 			timeLeft = 0;
+			if (!ProjectileLoader.PreKill(this, num)) {
+				active = false;
+				return;
+			}
+
 			if (type == 686) {
 				Main.PlayTrackedSound(SoundID.DD2_BetsyFireballImpact, Center);
 			}
@@ -38093,9 +_,13 @@
 									if (Main.tileDungeon[Main.tile[num824, num825].type] || Main.tile[num824, num825].type == 88 || TileID.Sets.BasicChest[Main.tile[num824, num825].type] || Main.tile[num824, num825].type == 26 || Main.tile[num824, num825].type == 107 || Main.tile[num824, num825].type == 108 || Main.tile[num824, num825].type == 111 || Main.tile[num824, num825].type == 226 || Main.tile[num824, num825].type == 237 || Main.tile[num824, num825].type == 221 || Main.tile[num824, num825].type == 222 || Main.tile[num824, num825].type == 223 || Main.tile[num824, num825].type == 211 || Main.tile[num824, num825].type == 404)
 										flag4 = false;
 
+									//patch file: num824, num825
 									if (!Main.hardMode && Main.tile[num824, num825].type == 58)
 										flag4 = false;
 
+									if (!TileLoader.CanExplode(num824, num825))
+										flag4 = false;
+
 									if (flag4) {
 										WorldGen.KillTile(num824, num825, false, false, false);
 										if (!Main.tile[num824, num825].active() && Main.netMode != 0)
@@ -38106,7 +_,7 @@
 								if (flag4) {
 									for (int num829 = num824 - 1; num829 <= num824 + 1; num829++) {
 										for (int num830 = num825 - 1; num830 <= num825 + 1; num830++) {
-											if (Main.tile[num829, num830] != null && Main.tile[num829, num830].wall > 0 && flag3) {
+											if (Main.tile[num829, num830] != null && Main.tile[num829, num830].wall > 0 && flag3 && WallLoader.CanExplode(num829, num830, Main.tile[num829, num830].wall)) {
 												WorldGen.KillWall(num829, num830, false);
 												if (Main.tile[num829, num830].wall == 0 && Main.netMode != 0)
 													NetMessage.SendData(17, -1, -1, null, 2, num829, num830, 0f, 0, 0, 0);
@@ -38396,10 +_,15 @@
 				}
 			}
 
+			ProjectileLoader.Kill(this, num);
 			active = false;
 		}
 
 		public Color GetAlpha(Color newColor) {
+			Color? modColor = ProjectileLoader.GetAlpha(this, newColor);
+			if (modColor.HasValue)
+				return modColor.Value;
+
 			if (type == 270)
 				return new Color(255, 255, 255, Main.rand.Next(0, 255));
 
