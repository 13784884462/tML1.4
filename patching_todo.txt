//Mirsario:
	//Lighting:
		//Re-add TileLoader.NearbyEffects calls (perhaps multiple) to somewhere in SceneMetrics
		
		//Re-add this MusicBox logic, to somewhere in SceneMetrics:
			if (TileLoader.IsModMusicBox(tile) && tile.frameX >= 36)
				Main.musicBox = SoundLoader.tileToMusic[tile.type][tile.frameY / 36 * 36];
		
		//Call this at the end of SceneMetrics.ScanAndExportToMain:
			WorldHooks.TileCountsAvailable(_tileCounts);
		
		//Resize the arrays that ScreenMetrics.UpdateOreFinderData uses.

	//TileID:
		//Add ids 477 and 492 to Sets.Grass.

	//WorldGen:
		//Call this before `AddGenerationPass("Reset"` in WorldGen:
			WorldHooks.PreWorldGen();
		
		//Re-add progress message details in "Micro Biomes" generation pass with messages like this:
			progress.Message = Lang.gen[76] + "..Enchanted Swords";
		
		//Add TileLoader.CanGrowModTree check to WorldGen.IsTileTypeFitForTree
		
		//Add this to i<5 for loop in TreeGrowFXCheck:
			TileLoader.TreeGrowthFXGore(tile2.type, ref passStyle);
				if (passStyle > 0)
					break;

			TileLoader.PalmTreeGrowthFXGore(tile2.type, ref passStyle);
				if (passStyle > 0)
					break;
				
		//Add this to TileID.Sets.CommonSapling check in EmptyTileCheck
			|| TileLoader.IsSapling(Main.tile[i, j].type)
			
		//Use this in IsLockedDoor:
			TileLoader.OpenDoorID(Main.tile[i, j]) < 0
			
		//Call this in KillTile_GetTileDustAmount:
			TileLoader.NumDust(i, j, tileCache.type, fail, ref result);
			
		//Check for this in IsContainer:
			TileLoader.IsDresser(tile.type)
			
		//Check for this somewhere at KillTile_GetTreeDrops
			TileLoader.CanDropAcorn(Main.tile[i, m].type)
			
		//Call this somewhere at KillTile_GetTreeDrops
			TileLoader.DropPalmTreeWood(Main.tile[i, num31].type, ref num23);
			
		//Remove this check in PlaceTile and PlaceObject:
			(num >= 623)
			
		//Re-add all needed TileLoader.Drop(x,y,type) checks. They're usually needed before 'destroyObject = false' lines.
		
		//Re-add these calls to UpdateWorld
			TileLoader.RandomUpdate(num6, num7, Main.tile[num6, num7].type);
			WallLoader.RandomUpdate(num6, num7, Main.tile[num6, num7].wall);
		
		//Add this call to UpdateWorld() after the gen check.
			WorldHooks.PreUpdate();
		
		//Add this call to end of UpdateWorld():
			WorldHooks.PostUpdate();
			
		//Add this call to the end of the if (Main.tile[x, y].active()) check in KillTile_GetTreeDrops():
			TileLoader.DropTreeWood(Main.tile[num29, n].type, ref dropItem);
		
		//Add this patch to UpdateWorld():
			-float num6 = Main.maxTilesX / 4200;
			+float num6 = Main.maxTilesX / 4200f; // Selfish fix for falling stars on extra small worlds
			
		//Add the following in front of this > https://i.imgur.com/hA0mqt7.png < place:
			case int _ when TileLoader.IsDresser(type):
			
		//Reimplement this call and check in KillWall_PlaySounds:
			WallLoader.KillWall(i, j, tile.wall, ref fail);
			
			if (!WallLoader.KillSound(i, j, tile.wall)) {}
		
		//Ensure that KillTile_GetTileDustAmount and its calls all have x,y parameters, to pass to the following call at the bottom of it:
			TileLoader.NumDust(x, y, tileCache.type, fail, ref result);
			
		//Search for "NPC.CountNPCS(num5) < 5" and add the following before the if check it's in:
			TileLoader.DropCritterChance(i, j, tileCache.type, ref num, ref num2, ref num3);
			
		//Replace all 'type == 88' checks (except those in Dust code) with the following:
			TileLoader.IsDresser(tile.type)
			
		//Reimplement the following hook:
			TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem);
			
		//Add this to the start of KillTile_PlaySounds:
			if (!TileLoader.KillSound(i, j, type)) {
				return;
			}
			
		//Reimplement these unsorted broken patches:
			//
		   |					num23 = 2504;
		   |				}
		   |
		   |-				if (num23 > 0) {
		   |+				bool vanillaDrop = TileLoader.Drop(i, j, tile.type);
		   |+				if (vanillaDrop && num23 > 0) {
		   |					int num41 = 1;
		   |					if (flag)
		   |						num41++;
		   |			//B
		   |			SquareTileFrame(i, j);
		   |		}
		   |
			
		   |-		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache) {
		   |+		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache, int i, int j) {
		   |			int result = 10;
		   |			if (tileCache.type == 231)
		   |				result = 6;
		   |			//C
		   |			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
		   |				flag = true;
		   |

		   |-			if (num >= 0) {
		   |+			if (TileLoader.CreateDust(i, j, tileCache.type, ref num) && num >= 0) { // TODO, fix
		   |				if (tileCache.type == 352 && num == 5) {
		   |					int num15 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 5, 0f, 0f, 100);
		   |					Main.dust[num15].scale = 1.5f;
			
			
		   //Replace some checks for grass tile ids with TileID.Sets.Grass checks:
		   |@@ -39670,34 +39873,34 @@
		   | 													if (mergeLeft)
		   | 														right = num;
		   | 												}
		   |-												else if (right == 147) {
		   |+												else if (right > -1 && TileID.Sets.Snow[right]) {
		   | 													TileFrame(i + 1, j);
		   | 													if (mergeLeft)
		   | 														right = num;
		   | 												}
		   |-												if (up == 2 || up == 23 || up == 109 || up == 199)
		   |+												if (up > -1 && TileID.Sets.Grass[up])
		   | 													up = num;
		   |-												if (down == 2 || down == 23 || down == 109 || down == 199)
		   |+												if (down > -1 && TileID.Sets.Grass[down])
		   | 													down = num;
		   |-												if (left == 2 || left == 23 || left == 109 || left == 199)
		   |+												if (left > -1 && TileID.Sets.Grass[left])
		   | 													left = num;
		   |-												if (right == 2 || right == 23 || right == 109 || right == 199)
		   |+												if (right > -1 && TileID.Sets.Grass[right])
		   | 													right = num;
		   | 												if (upLeft > -1 && Main.tileMergeDirt[upLeft])
		   | 													upLeft = num;
		   |-												else if (upLeft == 2 || upLeft == 23 || upLeft == 109 || upLeft == 199)
		   |+												else if (upLeft > -1 && TileID.Sets.Grass[upLeft])
		   | 													upLeft = num;
		   | 												if (upRight > -1 && Main.tileMergeDirt[upRight])
		   | 													upRight = num;
		   |-												else if (upRight == 2 || upRight == 23 || upRight == 109 || upRight == 199)
		   |+												else if (upRight > -1 && TileID.Sets.Grass[upRight])
		   | 													upRight = num;
		   | 												if (downLeft > -1 && Main.tileMergeDirt[downLeft])
		   | 													downLeft = num;
		   |-												else if (downLeft == 2 || downLeft == 23 || downLeft == 109 || downLeft == 199)
		   |+												else if (downLeft > -1 && TileID.Sets.Grass[downLeft])
		   | 													downLeft = num;
		   | 												if (downRight > -1 && Main.tileMergeDirt[downRight])
		   | 													downRight = num;
		   |-												else if (downRight == 2 || downRight == 23 || downRight == 109 || downRight == 199)
		   |+												else if (downRight > -1 && TileID.Sets.Grass[downRight])
		   | 													downRight = num;
		   | 												TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
		   | 												TileMergeAttempt(num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);

//Rartrin
	//Projectile.FishingCheck
		//Make PlayerHooks.CatchFish and other related hooks use the new FishingAttempt struct.
		//Move PlayerHooks.CatchFish and fishing related hooks to be each of the FishingCheck submethods.
		